/*
    O(1)으로 하기 위해 비트 연산자를 사용한다.
*/
#include <iostream>
#include <string>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    // x가 집합에 존재하면 2진수 bit의 x번째 자리가 1
    // ex) S = {1, 3, 4} -> bit = 0b000...011010 (1, 3, 4번째가 1, 나머지는 0)
    // 1~20이므로 0번째 자리부터 20번째 자리까지 21자리가 필요한데 int는 4바이트이므로 가능
    int m, x, bit = 0; // 01111010
    string op;

    cin >> m;
    while (m--) {
        cin >> op;

        if (op == "add") {
            cin >> x;
            bit |= (1 << x);
            // 1 << x 는 1을 x자리만큼 이동 -> x번째 자리가 1이 됨
            // bit = bit | (1 << x) 는 or연산으로 x번째 자리가 0 -> 1, 1 -> 1 이 됨
            // ex) bit = 000111, x = 4
            // ex) 000110 | 010000 -> 010110
        }
        else if (op == "remove") {
            cin >> x;
            bit &= ~(1 << x);
            // 0과 and연산을 하면 무조건 0, 1과 and연산을 하면 유지
            // ex) bit = 000110, x = 2
            // ex) 000100 -> 111011; 000110 & 111011 -> 000010 (2번째만 0으로 바뀌고 유지됨)
        }
        else if (op == "check") {
            cin >> x;
            cout << ((bit & (1 << x)) ? 1 : 0) << '\n';
            // 현재 bit와 입력받은 (1 << x)와 and 연산
            // ex) bit = 001110, x = 2; 001110 & 000100 -> 000100 (참)
            // ex) bit = 001010, x = 2; 001010 & 000100 -> 000000 (거짓)
        }
        else if (op == "toggle") {
            cin >> x;
            bit ^= (1 << x);
            // ^는 xor로 다르면 1, 같으면 0이다.
            // 즉, bit의 1과 xor연산하면 0은 1이되고, 1은 0이 된다. 따라서 x자리는 바뀐다.
            // 그러나 bit의 0과 xor연산하면 0은 0이되고, 1은 1이된다. 따라서 x자리가 아닌 수는 유지된다.
            // ex) bit = 001110, x = 2; 001110 ^ 000100 -> 001010으로 2번째 자리가 존재 -> 제거
            // ex) bit = 001010, x = 2; 001010 ^ 000100 -> 001110으로 2번째 자리가 없음 -> 존재
        }
        else if (op == "all") {
            bit = (1 << 21) - 2;
            // 1번째 자리부터 20번째 자리까지 1로 채워야 한다.
            // 즉 21번 쉬프트해서 0이 20개 있는 2^21을 만들고 (1000...000)
            // 1을 빼서 1이 20개 있는 이진수를 만들고 (111...111)
            // 다시 1을 빼서 0의 자리수를 0으로 만든다. (111...110)
        }
        else if (op == "empty") {
            bit = 0; // 모든 자리수 0
        }
    }

    return 0;
}