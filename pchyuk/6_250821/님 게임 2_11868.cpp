/* 나의 풀이 : 박찬혁 */
/* 풀이 과정 : "XOR 연산" */
/* 사용된 알고리즘 : 게임 이론, 스프라그–그런디 정리 */
/* 링크 : https://www.acmicpc.net/problem/11868 */

#include <iostream>
using namespace std;

int main(){
    
    int n, p, result = 0; // n: 돌무더기의 개수, p: 각 돌무더기에 있는 돌의 개수, result: 님 합(Nim-Sum)을 저장할 변수
    
    cin >> n; // 돌무더기의 개수(n)를 입력받는다.
    
    for (int i = 0; i < n; i++){ // n개의 돌무더기에 대해 반복하면서
        
        cin >> p; // i번째 돌무더기의 돌 개수(p)를 입력받는다.
        
        result ^= p; // 중요!!! "XOR 연산"
        // result 변수에 현재 돌무더기의 돌 개수(p)를 XOR 연산한다..
        // 이것이 바로 스프라그-그런디 정리에 따라 전체 게임의 그런디 수, 즉 '님 합'을 구하는 과정
        // 각 돌무더기의 돌 개수 p가 그 자체로 해당 단일 게임의 그런디 수(g-number)이기 때문
        // result = (첫 번째 돌 개수) ^ (두 번째 돌 개수) ^ ... ^ (n번째 돌 개수)
    }

    // 모든 돌무더기의 돌 개수를 XOR한 최종 결과(님 합)를 확인
    if (result == 0) {
        
        cout << "cubelover";
        // 님 합이 0이면, 이 게임은 선공이 '패배하는 상태(P-position)'이다.
        // 즉, 먼저 시작하는 플레이어(koosaga)는 어떻게 수를 두어도 상대방에게 이길 수 있는 상태를 만들어주게 된다.
        // 따라서 후공인 cubelover가 반드시 이기게 된다.
    }
    else {
        
        cout << "koosaga";
        // 님 합이 0이 아니면, 이 게임은 선공이 '승리하는 상태(N-position)'이다.
        // 즉, 먼저 시작하는 플레이어(koosaga)는 적절한 수를 두어 상대방에게 님 합이 0인 상태를 넘겨줄 수 있다.
        // 이 과정을 반복하면 선공인 koosaga가 반드시 이기게 된다.
    }
    
    return 0;
}


// 31게임을 예로 듭시다
// 스프라그 그런디 정리

// 31게임의 규칙은 다들 알테니 생략
// 31을 먼저 말하면 진다 == 30을 먼저 말하면 이긴다
// 내가 26을 불렀을 때
// 상대가 27 28 29 -> 나는 30
// 상대가 27 28 -> 나는 29 30
// 상대가 27 -> 나는 28 29 30

// 내가 부를 수 있는 최소 숫자의 개수 + 상대가 부를 수 있는 최대의 숫자 개수의 합이 항상 4가 되도록
// 30 26 22 18 14 10 6 2
// 결론: 선공이 1,2를 부르고, 무조건 상대 숫자 + 나 숫자 개수의 합이 4가 되도록 하면 이김

// 4
// 1 2 3 4 

// 2개일때: 같으면 0 다르면 1
// 3개 이상일때: 1이 홀수개면 1

// 0001 // 1
// 0010 // 2
// 0011 // 3
// 0100 // 4
// 0100 -> 4 != 0 koosaga

// XOR 연산의 특징
// 1. a ^ 0 = a
// 2. a ^ a = 0