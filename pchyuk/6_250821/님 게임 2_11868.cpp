/* 나의 풀이 : 박찬혁 */
/* 풀이 과정 : "XOR 연산" */
/* 사용된 알고리즘 : 게임 이론, 스프라그–그런디 정리 */
/* 링크 : https://www.acmicpc.net/problem/11868 */

#include <iostream>
using namespace std;

int main(){
    
    int n, p, result = 0; // n: 돌무더기의 개수, p: 각 돌무더기에 있는 돌의 개수, result: 님 합(Nim-Sum)을 저장할 변수
    
    cin >> n; // 돌무더기의 개수(n)를 입력받는다.
    
    for (int i = 0; i < n; i++){ // n개의 돌무더기에 대해 반복하면서
        
        cin >> p; // i번째 돌무더기의 돌 개수(p)를 입력받는다.
        
        result ^= p; // 중요!!! "XOR 연산"
        // result 변수에 현재 돌무더기의 돌 개수(p)를 XOR 연산한다..
        // 이것이 바로 스프라그-그런디 정리에 따라 전체 게임의 그런디 수, 즉 '님 합'을 구하는 과정
        // 각 돌무더기의 돌 개수 p가 그 자체로 해당 단일 게임의 그런디 수(g-number)이기 때문
        // result = (첫 번째 돌 개수) ^ (두 번째 돌 개수) ^ ... ^ (n번째 돌 개수)
    }

    // 모든 돌무더기의 돌 개수를 XOR한 최종 결과(님 합)를 확인
    if (result == 0) {
        
        cout << "cubelover";
        // 님 합이 0이면, 이 게임은 선공이 '패배하는 상태(P-position)'이다.
        // 즉, 먼저 시작하는 플레이어(koosaga)는 어떻게 수를 두어도 상대방에게 이길 수 있는 상태를 만들어주게 된다.
        // 따라서 후공인 cubelover가 반드시 이기게 된다.
    }
    else {
        
        cout << "koosaga";
        // 님 합이 0이 아니면, 이 게임은 선공이 '승리하는 상태(N-position)'이다.
        // 즉, 먼저 시작하는 플레이어(koosaga)는 적절한 수를 두어 상대방에게 님 합이 0인 상태를 넘겨줄 수 있다.
        // 이 과정을 반복하면 선공인 koosaga가 반드시 이기게 된다.
    }
    
    return 0;
}