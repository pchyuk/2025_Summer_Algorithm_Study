// 나의 풀이 - 박찬혁
// 풀이 방법 : 0키로부터 5키로까지는 초기값을 저장해 두고, 이후에는 먼저 5키로씩 빼보면서 확인해 보고, 이후 3키로씩 빼본다.
// 5키로를 먼저 빼야 더 적은 수의 봉지로 나눌 수 있다.
// 사용된 알고리즘 : dp, 그리디 알고리즘

#include <stdio.h>
#include <stdlib.h>
int main(){
    int n;
    scanf("%d", &n);

    int* sugar = (int*)calloc(n+1, sizeof(int)); // n+1개의 int 공간을 동적 할당하고, 0으로 초기화한다. 
  
    // 초기값 설정
    sugar[0] = sugar[1] = sugar[2] = -1; // 0,1,2키로 설탕은 3,5키로로 나눌 수 없다.(당연)
    sugar[3] = 1; // 설탕이 3키로 있다면 그대로 봉지 1개에 싸서 배달하면 된다.
    sugar[4] = -1; // 설탕 4키로는 3, 5키로로 나눌 수 없다.
    sugar[5] = 1; // 설탕이 5키로 있다면 그대로 벙지 1개에 싸서 배달하면 된다.

    for(int i=6; i<=n; i++){
        if(sugar[i-5] != -1){ // i-1키로의 설탕을 나눌 수 있다면
            sugar[i] = sugar[i-5] + 1; // 나누어 놓은 봉지의 수에 5키로 봉지 1개를 더한다.
        }
        else if(sugar[i-3] != -1){ // i-3키로의 설탕을 나눌 수 있다면
            sugar[i] = sugar[i-3] + 1; // 나누어 놓은 봉지 수에 3키로 봉지 1개를 더한다.
        }
        else sugar[i] = -1; // 둘 다 아니라면 못 나눈다.
    }

    printf("%d\n", sugar[n]); // 결괏값 출력
    free(sugar); // 공간을 동적 할당해서 사용했으므로 다 사용한 후에는 동적 할당을 해제해 준다.
    return 0; // 끄읏
}
