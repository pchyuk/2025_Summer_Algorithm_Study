/* 나의 풀이 - 박찬혁 */
/* 풀이 과정 : 폭탄의 위치를 알려 주는 mine 배열과 현재 보드판의 상태를 알려주는 board 배열을 선언하고, 
board 판의 특정 칸이 열려있을 때 그 칸이 폭탄인지 아닌지 판단한 후, 해당 칸을 기준으로 상하좌우 대각선의 8칸을 검사하여
주위에 폭탄이 몇 개 있는지 카운트한다. 이때 검사하는 칸이 0부터 n 사이의 범위 안에 들어와야 한다. 
폭탄이 터졌는지의 여부에 따라 주변 폭탄 개수를 저장하는 위치가 달라진다. */
/* 사용된 알고리즘 : 구현 */
/* 특이사항 : 처음에 문제를 잘못 읽어서 폭탄이 터지는 경우가 없는 줄 알았고, 문제를 제대로 이해한 이후에는 
주위의 폭탄 개수를 카운트하는 과정에서 범위 설정을 해주지 않아서 계속 오답이 나왔다. 당연하다 생각되는 것들도 확인하자. */
/* 링크 : https://www.acmicpc.net/problem/4396 */

#include <iostream>
using namespace std;

char mine[10][10]; // 폭탄의 위치를 저장
char board[10][10]; // 보드판의 상태를 저장

int main(){
    cin.tie(0);
    cout.tie(0);
    ios_base::sync_with_stdio(0);
    int n, boom = 0;
    cin >> n; // 보드판의 사이즈를 입력받는다.

    for(int i=0; i<n; i++){
        for(int j=0; j<n; j++){
            cin >> mine[i][j]; // 폭탄의 위치를 입력받는다.
        }
    }

    for(int i=0; i<n; i++){
        for(int j=0; j<n; j++){
            cin >> board[i][j]; // 보드판의 상태를 입력받는다.
            // 만약 i행 j열의 칸이 열렸는데 그 위치에 폭탄이 있다면
            // 퍼-엉(boom 값을 1로 바꾼다.)
            if(board[i][j] == 'x' && mine[i][j] == '*') boom = 1;
        }
    }
    
    for(int i=0; i<n; i++){
        for(int j=0; j<n; j++){
            if(board[i][j] == 'x'){ // i행 j열의 칸이 열려있다면
                int count = 0;
                for(int x=i-1; x<=i+1; x++){
                    for(int y=j-1; y<=j+1; y++){ // 해당 칸을 중심으로 상하좌우 대각선의 총 8칸을 검사한다.
                        // 중요!! 8칸을 검사할 때 범위 설정을 해 줘야 한다. 안그러면 틀린다.
                        // 이것때문에 1시간 날렸다...
                        // 당연히 범위 바깥의 값(예 : board[-1][-1])에는 '*'값이 안 들어있을것 같아서 무시했다가 혼쭐났다.
                        // 범위 안에 폭탄이 있으면 카운트를 올려준다.
                        if(x>=0 && x<n && y>=0 && y<n && mine[x][y] == '*') count++;
                    }
                }
                // boom값이 0이라면(폭탄을 건드리지 않았다면)
                // 'board' 판에 해당 칸의 주위의 폭탄 개수를 저장한다.
                if(boom == 0) board[i][j] = count + '0';

                // 만약 boom 값이 1이라면(폭탄을 건드렸다면)
                else if(boom == 1){
                    if(mine[i][j] == '*'); // 해당 위치가 폭탄이라면 가만히 냅둔다.(폭탄이 그대로 출력되도록)
                    else mine[i][j] = count + '0'; // 'mine' 판에 해당 칸의 주위의 폭탄 개수를 저장한다.
                }

                // 폭탄을 건드렸을 때 전체 폭탄의 위치를 어떻게 보여주지를 고민하다가
                // 폭탄이 터지지 않았을 때는 board판에, 터졌을 때는 mine 판에 저장하면 되겠다는 생각을 했다.
            }  
        }
    }

    for(int i=0; i<n; i++){
        for(int j=0; j<n; j++){
            if(boom == 0) cout << board[i][j]; // 폭탄이 터지지 않았다면 board판을.
            else if(boom == 1) cout << mine[i][j]; // 폭탄이 터졌다면 mine 판을 출력한다.
        }
        cout << "\n";
    }
    return 0;
}
